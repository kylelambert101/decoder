{"version":3,"sources":["decoder/cryptoTypes.ts","decoder/cryptoUtilities.ts","decoder/caesar/CaesarResults.tsx","decoder/atbash/AtbashResults.tsx","decoder/DecoderPage.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["codeLetters","splitIntoCodeCharacters","message","split","map","char","index","rawValue","codeLetter","find","c","toUpperCase","position","transform","toLowerCase","getSubstitutionResult","alternativeAlphabet","letter","indexOf","getCaesarResultWithOffset","offset","codedMessage","adjustedAlphabet","slice","join","getAtbashResult","reversedAlphabet","reverse","CaesarResults","resultStackId","getId","Stack","Label","htmlFor","horizontal","tokens","childrenGap","_letter","AtbashResults","DecoderPage","props","React","setMessage","style","paddingLeft","Item","horizontalAlign","TextField","label","value","onChange","_event","newMessage","width","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b3777c2a.chunk.js","sourcesContent":["export const codeLetters: string[] = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n];\n\nexport type CodeLetter = typeof codeLetters[number];\n\nexport interface CodeCharacter {\n  rawValue: string;\n  codeLetter: CodeLetter | undefined;\n  position: number;\n  transform: (c: string) => string;\n}\n","import { CodeCharacter, CodeLetter, codeLetters } from \"./cryptoTypes\";\n/**\n * Split a message string into an array of CodeCharacters\n * @param message\n */\nexport const splitIntoCodeCharacters = (message: string): CodeCharacter[] => {\n  return message.split(\"\").map((char, index) => ({\n    rawValue: char,\n    codeLetter: codeLetters.find((c) => c === char.toUpperCase()),\n    position: index,\n    transform:\n      char.toUpperCase() === char\n        ? (c: string) => c.toUpperCase()\n        : (c: string) => c.toLowerCase(),\n  }));\n};\n\n/**\n * Calculate the results of a substitution cipher of `message` using\n * `alternativeAlphabet` as the substitution\n * @param message\n * @param alternativeAlphabet\n */\nconst getSubstitutionResult = (\n  message: CodeCharacter[],\n  alternativeAlphabet: CodeLetter[]\n) => {\n  return message.map((letter) =>\n    typeof letter.codeLetter === \"undefined\"\n      ? letter.rawValue\n      : letter.transform(\n          alternativeAlphabet[codeLetters.indexOf(letter.codeLetter)]\n        )\n  );\n};\n\n/**\n * Calculate the resulting string if `message` is encoded by a Caesar\n * cipher with offset `offset`\n * @param message Message to decode\n * @param offset Number of positions to shift the cipher\n */\nexport const getCaesarResultWithOffset = (\n  message: string,\n  offset: number\n): string => {\n  const codedMessage = splitIntoCodeCharacters(message);\n  const adjustedAlphabet = [\n    ...codeLetters.slice(offset),\n    ...codeLetters.slice(0, offset),\n  ];\n\n  return getSubstitutionResult(codedMessage, adjustedAlphabet).join(\"\");\n};\n/**\n * Calculate the resulting string if `message` is encoded by an Atbash\n * cipher\n * @param message Message to decode\n */\nexport const getAtbashResult = (message: string): string => {\n  const codedMessage = splitIntoCodeCharacters(message);\n  const reversedAlphabet = [...codeLetters].reverse();\n  return getSubstitutionResult(codedMessage, reversedAlphabet).join(\"\");\n};\n","import * as React from \"react\";\nimport { Label, Stack, getId } from \"@fluentui/react\";\nimport { codeLetters } from \"../cryptoTypes\";\nimport { getCaesarResultWithOffset } from \"../cryptoUtilities\";\n\ninterface Props {\n  message: string;\n}\n\nconst CaesarResults = ({ message }: Props) => {\n  const resultStackId = getId(\"resultStack\");\n\n  return (\n    <Stack>\n      <Label htmlFor={resultStackId}>Caesar Cipher Results</Label>\n      <Stack horizontal tokens={{ childrenGap: \"1em\" }}>\n        <Stack tokens={{ childrenGap: \"0.25em\" }}>\n          {codeLetters.map((_letter, index) => (\n            <span>(Offset {index})</span>\n          ))}\n        </Stack>\n        <Stack tokens={{ childrenGap: \"0.25em\" }}>\n          {codeLetters.map((_letter, index) => (\n            <span>{getCaesarResultWithOffset(message, index)}</span>\n          ))}\n        </Stack>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport default CaesarResults;\n","import * as React from \"react\";\nimport { getAtbashResult } from \"../cryptoUtilities\";\nimport { Label, Stack, getId } from \"@fluentui/react\";\n\ninterface Props {\n  message: string;\n}\n\nconst AtbashResults = ({ message }: Props) => {\n  const resultStackId = getId(\"resultStack\");\n\n  return (\n    <Stack>\n      <Label htmlFor={resultStackId}>Atbash Cipher Results</Label>\n      <span>{getAtbashResult(message)}</span>\n    </Stack>\n  );\n};\n\nexport default AtbashResults;\n","import * as React from \"react\";\nimport { Stack, TextField } from \"@fluentui/react\";\nimport CaesarResults from \"./caesar/CaesarResults\";\nimport AtbashResults from \"./atbash/AtbashResults\";\n\ninterface Props {}\n\nconst DecoderPage = (props: Props) => {\n  const [message, setMessage] = React.useState(\"\");\n\n  const handleMessageChange = (\n    _event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>,\n    newMessage?: string | undefined\n  ) => setMessage(newMessage || \"\");\n\n  return (\n    <Stack style={{ paddingLeft: \"1em\" }}>\n      <Stack.Item>\n        <Stack horizontal horizontalAlign=\"start\">\n          <TextField\n            label=\"Message\"\n            value={message}\n            onChange={handleMessageChange}\n            style={{ width: 400 }}\n          />\n        </Stack>\n      </Stack.Item>\n      <Stack.Item>\n        <AtbashResults message={message} />\n      </Stack.Item>\n      <Stack.Item>\n        <CaesarResults message={message} />\n      </Stack.Item>\n    </Stack>\n  );\n};\n\nexport default DecoderPage;\n","import React from \"react\";\n\nimport DecoderPage from \"./decoder/DecoderPage\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <DecoderPage />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}