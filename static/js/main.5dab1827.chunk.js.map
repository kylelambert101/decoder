{"version":3,"sources":["decoder/cryptoTypes.ts","decoder/cryptoUtilities.ts","decoder/caesar/CaesarResults.tsx","decoder/atbash/AtbashResults.tsx","decoder/a1z26/A1Z26Results.tsx","decoder/vigenere/VigenereResults.tsx","decoder/DecoderPage.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["codeLetters","splitIntoCodeCharacters","message","split","map","char","index","rawValue","codeLetter","find","c","toUpperCase","position","transform","toLowerCase","getSubstitutionResult","inputAlphabet","outputAlphabet","letter","indexOf","getCaesarResultWithOffset","offset","codedMessage","adjustedAlphabet","slice","join","getAtbashResult","reversedAlphabet","reverse","isValidA1Z26Number","s","isNaN","Number","number","getA1Z26Result","letterDelimiter","matchAll","item","ind","codeNumber","undefined","m","getVigenereResult","key","currentKeyInd","getAlphabetStartingAt","length","CaesarResults","resultStackId","getId","Stack","Label","htmlFor","horizontal","tokens","childrenGap","Item","AtbashResults","resultId","id","A1Z26Results","VigenereResults","React","setKey","horizontalAlign","TextField","label","value","onChange","_event","newKey","underlined","style","width","DecoderPage","props","setMessage","paddingLeft","newMessage","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5dab1827.chunk.js","sourcesContent":["export const codeLetters = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n] as const;\n\nexport type CodeLetter = typeof codeLetters[number];\n\nexport interface CodeCharacter {\n  rawValue: string;\n  codeLetter: CodeLetter | undefined;\n  position: number;\n  transform: (c: string) => string;\n}\n","import { CodeCharacter, CodeLetter, codeLetters } from \"./cryptoTypes\";\n/**\n * Split a message string into an array of CodeCharacters\n * @param message\n */\nexport const splitIntoCodeCharacters = (message: string): CodeCharacter[] => {\n  return message.split(\"\").map((char, index) => ({\n    rawValue: char,\n    codeLetter: codeLetters.find((c) => c === char.toUpperCase()),\n    position: index,\n    transform:\n      char.toUpperCase() === char\n        ? (c: string) => c.toUpperCase()\n        : (c: string) => c.toLowerCase(),\n  }));\n};\n\n/**\n * Calculate the results of a substitution cipher of `message` using\n * `alternativeAlphabet` as the substitution\n * @param message\n * @param inputAlphabet\n * @param outputAlphabet\n */\nconst getSubstitutionResult = (\n  message: CodeCharacter[],\n  inputAlphabet: CodeLetter[],\n  outputAlphabet: CodeLetter[]\n) => {\n  return message.map((letter) =>\n    typeof letter.codeLetter === \"undefined\"\n      ? letter.rawValue\n      : letter.transform(\n          outputAlphabet[\n            (inputAlphabet || codeLetters).indexOf(letter.codeLetter)\n          ]\n        )\n  );\n};\n\n/**\n * Calculate the resulting string if `message` is encoded by a Caesar\n * cipher with offset `offset`\n * @param message Message to decode\n * @param offset Number of positions to shift the cipher\n */\nexport const getCaesarResultWithOffset = (\n  message: string,\n  offset: number\n): string => {\n  const codedMessage = splitIntoCodeCharacters(message);\n  const adjustedAlphabet = [\n    ...codeLetters.slice(offset),\n    ...codeLetters.slice(0, offset),\n  ];\n\n  return getSubstitutionResult(\n    codedMessage,\n    // Typescript doesn't like that I'm using a readonly array here but it's fine.\n    //@ts-ignore\n    codeLetters,\n    adjustedAlphabet\n  ).join(\"\");\n};\n/**\n * Calculate the resulting string if `message` is encoded by an Atbash\n * cipher\n * @param message Message to decode\n */\nexport const getAtbashResult = (message: string): string => {\n  const codedMessage = splitIntoCodeCharacters(message);\n  const reversedAlphabet = [...codeLetters].reverse();\n  return getSubstitutionResult(\n    codedMessage,\n    // Typescript doesn't like that I'm using a readonly array here but it's fine.\n    //@ts-ignore\n    codeLetters,\n    reversedAlphabet\n  ).join(\"\");\n};\n\n/**\n * Determine whether a string is numeric and between 1 and 26 (inclusive).\n * @param s\n */\nconst isValidA1Z26Number = (s: string): boolean => {\n  // Rule out non-numbers\n  if (s === \" \" || isNaN(Number(s))) return false;\n  const number = Number(s);\n  return 1 <= number && number <= 26;\n};\n\n/**\n * Calculate the resulting string if `message` is encoded by an A1Z26\n * cipher\n * @param message Message to decode\n */\nexport const getA1Z26Result = (\n  message: string,\n  letterDelimiter: string\n): string => {\n  // A1Z26 coded messages are set up differently from normal so parsing has to be custom\n  const pattern = /(\\d+|[^\\d])/g;\n  // Use a new `codeNumber` field because numbers aren't of type CodeLetter\n  const matches: (CodeCharacter & { codeNumber: number | undefined })[] = [\n    ...message.matchAll(pattern),\n  ].map((item, ind) => ({\n    rawValue: item[0],\n    codeNumber: isValidA1Z26Number(item[0])\n      ? // Cipher code is 1-indexed so subtract one\n        Number(item[0]) - 1\n      : undefined,\n    codeLetter: undefined,\n    position: ind,\n    transform: (c: string) => (c === letterDelimiter ? \"\" : c.toUpperCase()),\n  }));\n\n  return matches\n    .map((m) =>\n      m.transform(\n        typeof m.codeNumber === \"undefined\"\n          ? m.rawValue\n          : codeLetters[m.codeNumber]\n      )\n    )\n    .join(\"\");\n};\n\nexport const getAlphabetStartingAt = (letter: CodeLetter) => {\n  const ind = codeLetters.indexOf(letter);\n  return [...codeLetters.slice(ind), ...codeLetters.slice(0, ind)];\n};\n\nexport const getVigenereResult = (message: string, key: string): string => {\n  let currentKeyInd = 0;\n  return splitIntoCodeCharacters(message)\n    .map((char) =>\n      typeof char.codeLetter !== \"undefined\"\n        ? getSubstitutionResult(\n            [char],\n            getAlphabetStartingAt(\n              key[currentKeyInd++ % key.length] as CodeLetter\n            ),\n            // Typescript doesn't like that I'm using a readonly array here but it's fine.\n            //@ts-ignore\n            codeLetters\n          )\n        : char.rawValue\n    )\n    .join(\"\");\n};\n","import * as React from \"react\";\nimport { Label, Stack, getId } from \"@fluentui/react\";\nimport { codeLetters } from \"../cryptoTypes\";\nimport { getCaesarResultWithOffset } from \"../cryptoUtilities\";\n\ninterface Props {\n  message: string;\n}\n\nconst CaesarResults = ({ message }: Props) => {\n  const resultStackId = getId(\"resultStack\");\n\n  return (\n    <Stack>\n      <Label htmlFor={resultStackId}>Caesar Cipher Results</Label>\n      <Stack horizontal tokens={{ childrenGap: \"1em\" }}>\n        <Stack tokens={{ childrenGap: \"0.25em\" }}>\n          {codeLetters.map((letter, index) => (\n            <Stack.Item key={`${letter}OffsetLabel`}>\n              <span>(Offset {index})</span>\n            </Stack.Item>\n          ))}\n        </Stack>\n        <Stack tokens={{ childrenGap: \"0.25em\" }}>\n          {codeLetters.map((letter, index) => (\n            <Stack.Item key={`${letter}OffsetResult`}>\n              <span>{getCaesarResultWithOffset(message, index) || \"-\"}</span>\n            </Stack.Item>\n          ))}\n        </Stack>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport default CaesarResults;\n","import * as React from \"react\";\nimport { getAtbashResult } from \"../cryptoUtilities\";\nimport { Label, Stack, getId } from \"@fluentui/react\";\n\ninterface Props {\n  message: string;\n}\n\nconst AtbashResults = ({ message }: Props) => {\n  const resultId = getId(\"result\");\n\n  return (\n    <Stack>\n      <Label htmlFor={resultId}>Atbash Cipher Results</Label>\n      <span id={resultId}>{getAtbashResult(message) || \"-\"}</span>\n    </Stack>\n  );\n};\n\nexport default AtbashResults;\n","import * as React from \"react\";\nimport { getA1Z26Result } from \"../cryptoUtilities\";\nimport { Label, Stack, getId } from \"@fluentui/react\";\n\ninterface Props {\n  message: string;\n}\n\nconst A1Z26Results = ({ message }: Props) => {\n  const resultId = getId(\"result\");\n\n  return (\n    <Stack>\n      <Label htmlFor={resultId}>A1Z26 Cipher Results</Label>\n      <span id={resultId}>{getA1Z26Result(message, \"-\") || \"-\"}</span>\n    </Stack>\n  );\n};\n\nexport default A1Z26Results;\n","import * as React from \"react\";\nimport { getVigenereResult } from \"../cryptoUtilities\";\nimport { Label, Stack, getId, TextField } from \"@fluentui/react\";\n\ninterface Props {\n  message: string;\n}\n\nconst VigenereResults = ({ message }: Props) => {\n  const [key, setKey] = React.useState(\"SECRET_KEY\");\n\n  const handleKeyChange = (\n    _event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>,\n    newKey?: string | undefined\n  ) => {\n    if (typeof newKey !== \"undefined\") setKey(newKey.toUpperCase());\n  };\n\n  const resultId = getId(\"result\");\n\n  return (\n    <Stack>\n      <Stack horizontal horizontalAlign=\"start\" tokens={{ childrenGap: \"1em\" }}>\n        <Label htmlFor={resultId}>Vigenère Cipher Results</Label>\n        <TextField\n          label=\"Key\"\n          value={key}\n          onChange={handleKeyChange}\n          underlined\n          style={{ width: 100 }}\n        />\n      </Stack>\n      <span id={resultId}>{getVigenereResult(message, key) || \"-\"}</span>\n    </Stack>\n  );\n};\n\nexport default VigenereResults;\n","import * as React from \"react\";\nimport { Stack, TextField } from \"@fluentui/react\";\nimport CaesarResults from \"./caesar/CaesarResults\";\nimport AtbashResults from \"./atbash/AtbashResults\";\nimport A1Z26Results from \"./a1z26/A1Z26Results\";\nimport VigenereResults from \"./vigenere/VigenereResults\";\n\ninterface Props {}\n\nconst DecoderPage = (props: Props) => {\n  const [message, setMessage] = React.useState(\"\");\n\n  const handleMessageChange = (\n    _event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>,\n    newMessage?: string | undefined\n  ) => setMessage(newMessage || \"\");\n\n  return (\n    <Stack style={{ paddingLeft: \"1em\" }}>\n      <Stack.Item>\n        <Stack horizontal horizontalAlign=\"start\">\n          <TextField\n            label=\"Message\"\n            value={message}\n            onChange={handleMessageChange}\n            style={{ width: 400 }}\n          />\n        </Stack>\n      </Stack.Item>\n      <Stack.Item>\n        <AtbashResults message={message} />\n      </Stack.Item>\n      <Stack.Item>\n        <A1Z26Results message={message} />\n      </Stack.Item>\n      <Stack.Item>\n        <VigenereResults message={message} />\n      </Stack.Item>\n      <Stack.Item>\n        <CaesarResults message={message} />\n      </Stack.Item>\n    </Stack>\n  );\n};\n\nexport default DecoderPage;\n","import React from \"react\";\n\nimport DecoderPage from \"./decoder/DecoderPage\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <DecoderPage />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}